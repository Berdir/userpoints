<?php

// Copyright 2005-2007 Khalid Baheyeldin http://2bits.com
define('USERPOINTS_TRANS_UCPOINTS', 'userpoints_trans_ucpoints');
define('USERPOINTS_TRANS_LCPOINTS', 'userpoints_trans_lcpoints');
define('USERPOINTS_TRANS_UCPOINT', 'userpoints_trans_ucpoint');
define('USERPOINTS_TRANS_LCPOINT', 'userpoints_trans_lcpoint');
define('USERPOINTS_TRANS_UNCAT', 'userpoints_trans_uncat');

define('USERPOINTS_STATUS', 'userpoints_status');

define('USERPOINTS_POINTS_MODERATION', 'userpoints_points_moderation');

define('USERPOINTS_EXPIRY_DESCRIPTION', 'userpoints_expiry_description');
define('USERPOINTS_EXPIREON_DATE', 'userpoints_expireon_date');
define('USERPOINTS_EXPIREAFTER_DATE', 'userpoints_expireafter_date');
define('USERPOINTS_DISPLAY_MESSAGE', 'userpoints_display_message');

define('USERPOINTS_REPORT_USERCOUNT', 'userpoints_report_usercount');
define('USERPOINTS_REPORT_LIMIT', 'userpoints_report_limit');
define('USERPOINTS_REPORT_DISPLAYZERO', 'userpoints_report_displayzero');

define('USERPOINTS_CATEGORY_NAME', 'Userpoints');
define('USERPOINTS_CATEGORY_DEFAULT_VID', 'userpoints_category_default_vid');
define('USERPOINTS_CATEGORY_DEFAULT_TID', 'userpoints_category_default_tid');
define('USERPOINTS_CATEGORY_PROFILE_DISPLAY_TID', 'userpoints_category_profile_display_tid');
define('USERPOINTS_TRANSACTION_TIMESTAMP', 'userpoints_transaction_timestamp');

/**
 * Returns an array of common translation placeholders.
 */
function userpoints_translation() {
  static $trans;

  if (!isset($trans)) {
    $trans = array(
      '!Points' => check_plain(variable_get(USERPOINTS_TRANS_UCPOINTS, 'Points')),
      '!points' => check_plain(variable_get(USERPOINTS_TRANS_LCPOINTS, 'points')),
      '!Point' => check_plain(variable_get(USERPOINTS_TRANS_UCPOINT, 'Point')),
      '!point' => check_plain(variable_get(USERPOINTS_TRANS_LCPOINT, 'point')),
      '!Uncategorized' => check_plain(variable_get(USERPOINTS_TRANS_UNCAT, 'General')),
    );
  }
  return $trans;
}

/*
 * Returns an array of possible transaction statuses.
 */
function userpoints_txn_status() {
  static $stati;
  if (empty($stati)) {
    $stati = array(
      UserpointsTransaction::STATUS_APPROVED => t('Approved'),
      UserpointsTransaction::STATUS_PENDING => t('Pending'),
      UserpointsTransaction::STATUS_DECLINED => t('Declined'),
    );
  }
  return $stati;
}

/**
 * Implements hook_help().
 */
function userpoints_help($path, $arg) {
  switch ($path) {
    case 'admin/settings/userpoints':
      return t('Configure userpoints moderation and branding translation');
    case 'admin/help#userpoints':
      return t('Users earn !points as they post nodes, comments, and vote on nodes', userpoints_translation());
  }
}

/**
 * Checks access for administrative functionality.
 *
 * Provides simplified access checks for the administrative permissions:
 * - administer userpoints
 * - add userpoints
 * - edit userpoints
 * - moderate userpoints
 *
 * @param $type
 *   The access type to check. The administer permission has access to all of
 *   them. Supported strings:
 *   - list: Access to the userpoints list, default local task. All
 *           administrative permissions have access to this.
 *   - add: Permission to add new userpoints transactions.
 *   - edit: Permission to edit existing userpoints transactions.
 *   - moderate: Permission to approve/decline pending transactions.
 *   - administer: Unlimited userpoints permissions, used for settings page.
 *
 * @return
 *   TRUE if the current user has access, FALSE if not.
 */
function userpoints_admin_access($type = 'list') {
  // Administer userpoints permission has full access.
  if (user_access('administer userpoints')) {
    return TRUE;
  }

  switch ($type) {
    // All admin permissions have access to the list page.
    case 'list':
      return user_access('add userpoints') || user_access('edit userpoints') || user_access('moderate userpoints');
      break;

    case 'add':
      return user_access('add userpoints');
      break;

    case 'edit':
      return user_access('edit userpoints');
      break;

    case 'moderate':
      return user_access('moderate userpoints');
      break;

    case 'administer':
      // administer permission was already checked, this exists for
      // documentation purposes only.
      break;
  }
  return FALSE;
}

/**
 * Implements hook_menu().
 */
function userpoints_menu() {
  $items = array();
  $items['admin/config/people/userpoints'] = array(
      'title' => '!Points',
      'title arguments' => userpoints_translation(),
      'description' => strtr('Manage !points', userpoints_translation()),
      'page callback' => 'drupal_get_form',
      'page arguments' => array('userpoints_admin_points'),
      'access callback' => 'userpoints_admin_access',
      'access arguments' => array('list'),
      'file' => 'userpoints.admin.inc',
  );
  $items['admin/config/people/userpoints/list'] = array(
      'title' => 'Totals',
      'file' => 'userpoints.admin.inc',
      'type' => MENU_DEFAULT_LOCAL_TASK,
      'weight' => -2,
  );
  $items['admin/config/people/userpoints/transaction'] = array(
      'title' => 'Transactions',
      'title arguments' => userpoints_translation(),
      'description' => 'List transactions',
      'page callback' => 'drupal_get_form',
      'page arguments' => array('userpoints_admin_transactions', FALSE),
      'access callback' => 'userpoints_admin_access',
      'access arguments' => array('edit'),
      'file' => 'userpoints.admin.inc',
      'type' => MENU_LOCAL_TASK,
      'weight' => 0,
  );

  $items['admin/config/people/userpoints/moderate'] = array(
      'title' => 'Moderation',
      'title arguments' => userpoints_translation(),
      'description' => strtr('Review !points in moderation', userpoints_translation()),
      'page callback' => 'drupal_get_form',
      'page arguments' => array('userpoints_admin_transactions', TRUE),
      'access callback' => 'userpoints_admin_access',
      'access arguments' => array('moderate'),
      'file' => 'userpoints.admin.inc',
      'type' => MENU_LOCAL_TASK,
      'weight' => 2,
  );
  $items['admin/config/people/userpoints/add'] = array(
      'title' => 'Add !points transaction',
      'title arguments' => userpoints_translation(),
      'description' => 'Admin add/delete userpoints',
      'page callback' => 'drupal_get_form',
      'page arguments' => array('userpoints_admin_txn', 4),
      'access callback' => 'userpoints_admin_access',
      'access arguments' => array('add'),
      'file' => 'userpoints.admin.inc',
      'type' => MENU_LOCAL_ACTION,
      'weight' => 0,
  );

  $items['admin/config/people/userpoints/settings'] = array(
      'title' => '!Points settings',
      'description' => strtr('Settings for !points', userpoints_translation()),
      'title arguments' => userpoints_translation(),
      'page callback' => 'drupal_get_form',
      'page arguments' => array('userpoints_admin_settings'),
      'access callback' => 'userpoints_admin_access',
      'access arguments' => array('administer'),
      'file' => 'userpoints.admin.inc',
      'type' => MENU_LOCAL_TASK,
      'weight' => 10,
  );

  $items['userpoints'] = array(
      'title' => 'Users by !points',
      'title arguments' => userpoints_translation(),
      'page callback' => 'drupal_get_form',
      'page arguments' => array('userpoints_list_users'),
      'access arguments' => array('view userpoints'),
      'file' => 'userpoints.pages.inc',
      'type' => MENU_NORMAL_ITEM,
  );

  $items['userpoints/operation-autocomplete'] = array(
      'title' => 'Operation autocomplete',
      'page callback' => 'userpoints_operation_autocomplete',
      'access callback' => 'userpoints_admin_access',
      'access arguments' => array('add'),
      'file' => 'userpoints.admin.inc',
      'type' => MENU_CALLBACK,
  );

  $items['myuserpoints'] = array(
    'title' => 'My !points',
    'title arguments' => userpoints_translation(),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('userpoints_list_transactions'),
    'access callback' => 'userpoints_access_my_points',
    'file' => 'userpoints.pages.inc',
    'type' => MENU_NORMAL_ITEM,
    'menu_name' => 'user-menu',
  );

  $items['myuserpoints/%'] = array(
    'title' => 'My !points',
    'title arguments' => userpoints_translation(),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('userpoints_list_transactions', NULL, 1),
    'access callback' => 'userpoints_access_my_points',
    'file' => 'userpoints.pages.inc',
    'type' => MENU_NORMAL_ITEM,
    'menu_name' => 'user-menu',
  );

  $items['user/%user/points'] = array(
    'title' => '!Points',
    'title arguments' => userpoints_translation(),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('userpoints_list_transactions', 1),
    'access callback' => 'userpoints_access_my_points',
    'access arguments' => array(1),
    'file' => 'userpoints.pages.inc',
    'type' => MENU_LOCAL_TASK,
    'weight' => 1,
  );

  // There are separate, duplicated local tasks for transactions in the
  // administrative area, myuserpoints and the userpoints of another user.
  // They all need to be created separately because local tasks must be menu
  // router items, but it can be done in a loop since the only difference is
  // the path prefix and position of the argument.
  $local_task_prefixes = array(
    'admin/config/people/userpoints/transaction',
    'myuserpoints/transaction',
    'user/%user/points',
  );

  foreach ($local_task_prefixes as $local_task_prefix) {
    // The dynamic argument is always the first after the prefix.
    $pos = count(explode('/', $local_task_prefix));
    $items[$local_task_prefix . '/list'] = array(
      'title' => 'List',
      'type' => MENU_DEFAULT_LOCAL_TASK,
      'weight' => -15,
    );
    $items[$local_task_prefix . '/%userpoints_transaction/view'] = array(
      'title' => 'View',
      'page callback' => 'userpoints_view_transaction',
      'page arguments' => array($pos),
      'access callback' => 'userpoints_access_view_transaction',
      'access arguments' => array($pos),
      'file' => 'userpoints.pages.inc',
      'type' => MENU_LOCAL_TASK,
      'weight' => -10,
    );
    $items[$local_task_prefix . '/%userpoints_transaction/edit'] = array(
        'title' => 'Edit',
        'page callback' => 'drupal_get_form',
        'page arguments' => array('userpoints_admin_txn', $pos + 1, $pos),
        'access callback' => 'userpoints_admin_access',
        'access arguments' => array('edit'),
        'file' => 'userpoints.admin.inc',
        'type' => MENU_LOCAL_TASK,
        'weight' => -5,
    );
    $items[$local_task_prefix . '/%userpoints_transaction/approve'] = array(
        'title' => 'Approve',
        'title arguments' => userpoints_translation(),
        'page callback' => 'drupal_get_form',
        'page arguments' => array('userpoints_confirm_approve', $pos + 1, $pos),
        'access callback' => 'userpoints_admin_access_transaction_pending',
        'access arguments' => array($pos),
        'file' => 'userpoints.admin.inc',
        'type' => MENU_LOCAL_TASK,
    );
    $items['user/%user/points/%userpoints_transaction/decline'] = array(
        'title' => 'Decline',
        'title arguments' => userpoints_translation(),
        'page callback' => 'drupal_get_form',
        'page arguments' => array('userpoints_confirm_approve', $pos + 1, $pos),
        'access callback' => 'userpoints_admin_access_transaction_pending',
        'access arguments' => array($pos),
        'file' => 'userpoints.admin.inc',
        'type' => MENU_LOCAL_TASK,
    );
  }
  return $items;
}

/**
 * Implements hook_menu_local_tasks_alter().
 */
function userpoints_menu_local_tasks_alter(&$data, $router_item, $root_path) {
  // Add action link to add points on 'userpoints' administration pages.
  if (strpos($root_path, 'admin/config/people/userpoints/') !== FALSE) {

    // Don't display the action link on some pages like settings and
    // approve or decline confirmation forms.
    $blacklist = array('settings', 'approve', 'decline');
    foreach ($blacklist as $blacklisted_path) {
      if (strpos($root_path, $blacklisted_path) !== FALSE) {
        return;
      }
    }

    $item = menu_get_item('admin/config/people/userpoints/add');

    // For the transaction view pages, we want to directly link to the
    // user for this transaction.
    if (arg(4) == 'transaction' && (arg(6) == 'view' || arg(6) == 'edit')) {
      $transaction = userpoints_transaction_load(arg(5));
      $item['href'] .= '/' . $transaction->uid;
    }

    if ($item['access']) {
      $data['actions']['output'][] = array(
        '#theme' => 'menu_local_action',
        '#link' => $item,
      );
    }
  }
}

/**
 * Access callback for approve and decline local tasks.
 *
 * Only pending transactions can be approved or declined.
 */
function userpoints_admin_access_transaction_pending(UserpointsTransaction $transaction) {
  return $transaction->isPending() && userpoints_admin_access('moderate');
}

/**
 * Checks if user can access their points - used via hook_menu().
 *
 * @return
 *   TRUE if user has permissions to view userpoints and if the user is logged
 *   in.
 */
function userpoints_access_my_points($account = NULL) {
  global $user;

  if ($account && $user->uid != $account->uid) {
    return userpoints_admin_access('edit');
  }
  return (user_access('view userpoints') && user_is_logged_in()) || user_access('view own userpoints');
}

/**
 * Checks if a user has access to a transaction.
 *
 * @return
 *   TRUE if the user has permissions to view the transaction.
 */
function userpoints_access_view_transaction($transaction) {
  return userpoints_access_my_points($transaction->getUser());
}

/**
 * Implements hook_permission().
 */
function userpoints_permission() {
  return array(
    'view own userpoints' => array(
      'title' => t('View own !points', userpoints_translation()),
      'description' => t('Allows to view own !points, including own !point transactions.', userpoints_translation()),
    ),
    'view userpoints' => array(
      'title' => t('View all !points', userpoints_translation()),
      'description' => t('Allows to view the !points of other users, but not the transactions.', userpoints_translation()),
    ),
    'add userpoints' => array(
      'title' => t('Add new !point transactions', userpoints_translation()),
      'description' => t('Allows to create new !point transactions.', userpoints_translation()),
    ),
    'edit userpoints' => array(
      'title' => t('Edit !point transactions', userpoints_translation()),
      'description' => t('Allows to modify existing !point transactions, including the ability to view transaction history for all users.', userpoints_translation()),
    ),
    'moderate userpoints' => array(
      'title' => t('Moderate !point transactions', userpoints_translation()),
      'description' => t('Allows to approve or disapprove !point transactions.', userpoints_translation()),
    ),
    'administer userpoints' => array(
      'title' => t('Administer Userpoints'),
      'description' => t('Allows to configure the settings and includes full read and write access of all !point transactions.', userpoints_translation()),
    ),
  );
}

/**
 * Implements hook_theme().
 */
function userpoints_theme() {
  return array(
    'userpoints_view_category' => array(
      'render element' => 'element',
      'file' => 'userpoints.theme.inc',
    ),
    'userpoints_view_item' => array(
      'render element' => 'element',
      'file' => 'userpoints.theme.inc',
    ),
  );
}

/**
 * Implements hook_tokens().
 */
function userpoints_tokens($type, $tokens, array $data = array(), array $options = array()) {
  $url_options = array('absolute' => TRUE);
  if (isset($options['language'])) {
    $url_options['language'] = $options['language'];
    $language_code = $options['language']->language;
  }
  else {
    $language_code = NULL;
  }

  $replacements = array();

  if ($type == 'user' && !empty($data['user'])) {
    $user = $data['user'];
    foreach ($tokens as $name => $original) {
      switch ($name) {
        case 'points':
          $replacements[$original] = userpoints_get_current_points($user->uid);
          break;

        case 'maxpoints':
          $replacements[$original] = userpoints_get_max_points($user->uid);

        default:
          break;
      }
    }

    if ($points_tokens = token_find_with_prefix($tokens, 'points')) {
      $replacements += token_generate('userpoints', $points_tokens, $data, $options);
    }
    if ($points_tokens = token_find_with_prefix($tokens, 'maxpoints')) {
      $replacements += token_generate('maxuserpoints', $points_tokens, $data, $options);
    }
  }

  if ($type == 'userpoints' && !empty($data['user'])) {
    foreach ($tokens as $name => $original) {
      $tid = NULL;
      if ($name == 'all') {
        $tid = 'all';
      }
      else if (strpos($name, 'category-') === 0) {
        // Extract the category id from the string that looks like category-1.
        list(,$tid) = explode('-', $name);
      }
      if ($tid) {
        $replacements[$original] = userpoints_get_current_points($data['user']->uid, $tid);
      }
    }
  }

  if ($type == 'maxuserpoints' && !empty($data['user'])) {
    $uid = is_object($data['user']->uid) ? $data['user']->getIdentifier() : $data['user']->uid;
    foreach ($tokens as $name => $original) {
      $tid = NULL;
      if ($name == 'all') {
        $tid = 'all';
      }
      else if (strpos($name, 'category-') === 0) {
        // Extract the category id from the string that looks like category-1.
        list(,$tid) = explode('-', $name);
      }
      if ($tid) {
        $replacements[$original] = userpoints_get_max_points($uid, $tid);
      }
    }
  }
  return $replacements;
}

/**
 * Implements hook_token_info().
 */
function userpoints_token_info() {
  $types = array(
    'userpoints' => array(
      'name' => t('!Points', userpoints_translation()),
      'description' => t('Amount of !points a user has.', userpoints_translation()),
      'needs-data' => 'user',
    ),
    'maxuserpoints' => array(
      'name' => t('Maximal !points', userpoints_translation()),
      'description' => t('Maximal amount of !points a user had at any time.', userpoints_translation()),
      'needs-data' => 'user',
    ),
  );

  $tokens = array();

  $tokens['user']['points'] = array(
    'name' => t('!Points', userpoints_translation()),
    'description' => t('The amount of !points this user has. If there are multiple categories, only the default category is taken into account.', userpoints_translation()),
    'type' => 'userpoints',
  );

  $tokens['user']['maxpoints'] = array(
    'name' => t('Maximal !points', userpoints_translation()),
    'description' => t('The highest amount of !points a user had at any given point. If there are multiple categories, only the default category is taken into account.', userpoints_translation()),
    'type' => 'userpoints',
  );

  $categories = userpoints_get_categories();
  if (count($categories) > 1) {
    foreach ($categories as $tid => $category) {
      $tokens['userpoints']['category-' . $tid] = array(
        'name' => t('!Points in category %category', array_merge(array('%category' => $category), userpoints_translation())),
        'description' => t('The amount of !points this user has in that category.', userpoints_translation()),
      );

      $tokens['maxuserpoints']['category-' . $tid] = array(
        'name' => t('Maximal !points in category %category', array_merge(array('%category' => $category), userpoints_translation())),
        'description' => t('The highest amount of !points a user had at any given point in that category.', userpoints_translation()),
      );
    }
  }
  $tokens['userpoints']['all'] = array(
    'name' => t('Total !points', userpoints_translation()),
    'description' => t('Total amount of !points over all categories.', userpoints_translation()),
  );
  $tokens['maxuserpoints']['all'] = array(
    'name' => t('Total maximum !points', userpoints_translation()),
    'description' => t('Total amount of maximal !points over all categories.', userpoints_translation()),
  );

  return array(
    'types' => $types,
    'tokens' => $tokens,
  );
}

/**
 * Get current points of a user.
 *
 * @param $uid
 *   User ID of the user to get or lose the points.
 * @param $tid
 *   Term ID to get points for, or 'all'.
 *
 * @return
 *   Number of current points in that user's account.
 *
 * @ingroup userpoints_api
 */
function userpoints_get_current_points($uid = NULL, $tid = NULL) {
  $points = drupal_static(__FUNCTION__, array());
  if (!$uid) {
    global $user;
    $uid = $user->uid;
  }
  // 0 is a valid value for the Uncategorized category.
  if (!isset($tid)) {
    $tid = userpoints_get_default_tid();
  }
  if (!isset($points[$uid][$tid])) {
    if ($tid === 'all') {
      $points[$uid][$tid] = (int) db_query('SELECT points FROM {userpoints_total} WHERE uid = :uid', array(':uid' => $uid))->fetchField();
    }
    else {
      $points[$uid][$tid] = (int) db_query('SELECT points FROM {userpoints} WHERE uid = :uid AND tid = :tid', array(':uid' => $uid, ':tid' => $tid))->fetchField();
    }
  }
  return $points[$uid][$tid];
}

/**
 * Gets the number of maximal points of that user.
 *
 * @param $uid
 *   User id of the user to get or lose the points.
 *
 * @return
 *   Number of max points in that user's account.
 *
 * @ingroup userpoints_api
 */
function userpoints_get_max_points($uid = NULL, $tid = NULL) {
  $max = drupal_static(__FUNCTION__, array());

  // Check if uid is passed as a parameter.
  if (!$uid) {
    // It is not, so we use the currently logged in user's uid.
    global $user;
    $uid = $user->uid;
  }

  // Check if a term id is passed as a parameter.
  if (!isset($tid)) {
    // It is not, so get the default term id.
    $tid = userpoints_get_default_tid();
  }

  // Check if we have already cached the maximum for the user/term combination on previous calls.
  if (!isset($max[$uid][$tid])) {
    // We did not cache it.
    if ($tid === 'all') {
      // There is no term id, so we select the total.
      $max[$uid][$tid] = db_query('SELECT max_points FROM {userpoints_total} WHERE uid = :uid', array(':uid' => $uid))->fetchField();
    }
    else {
      // A term ID is specified, so fetch its maximum points.
      $max[$uid][$tid] = db_query('SELECT max_points FROM {userpoints} WHERE uid = :uid AND tid = :tid', array(':uid' => $uid, ':tid' => $tid))->fetchField();
    }
  }
  // Return the cached value.
  return $max[$uid][$tid];
}

/**
 * Grant a user points.
 *
 * The function excpects two required parameters, an operation string
 * and the amount of points. Optionally, a user id can be passed.
 *
 * The function then returns a UserpointsTransaction object, which provides
 * methods to add further details to the transaction. New transactions are saved
 * automatically through the __destruct() method. However, if transaction needs
 * to be saved immediately, save() can be called directly.
 *
 * Basic usage examples:
 * @code
 * // Adding points to the current user, relying on automatic saving.
 * userpoints_grant_points('mymodule_type_action', $points);
 *
 * // Grant points to another, add a entity reference to a node and save
 * // explicitly.
 * userpoints_grant_points('mymodule_type_otheraction', $points, $account->uid)
 *   ->setEntity($node)
 *   ->save();
 * @endcode
 *
 * A list of all available methods can be found in the UserpointsTransaction
 * documentation.
 *
 * @param $operation
 *   A string that can identify this transaction. Can be used to provide a
 *   custom, translatable, optionally dynamic reason for this transaction in
 *   transaction listings. See hook_userpoints_info().
 * @param $points
 *   A positive or negative point amount that should be assigned to the user.
 * @param $uid
 *   UID of the user that should be granted points. Optional, defaults to the
 *   current user.
 *
 * @return UserpointsTransaction
 *
 * @ingroup userpoints_api
 */
function userpoints_grant_points($operation, $points, $uid = NULL) {
  global $user;

  // Default to the current user if not set.
  if (empty($uid)) {
    $uid = $user->uid;
  }

  $transaction = new UserpointsTransaction();
  return $transaction->setOperation($operation)
    ->setPoints($points)
    ->setUid($uid);
}

/**
 * Determines the correct default expiration date.
 *
 * @return
 *   The default expiration date.
 */
function userpoints_get_default_expiry_date() {
  $expirydate = userpoints_date_to_timestamp(variable_get(USERPOINTS_EXPIREON_DATE, 0));
  if ($expirydate < REQUEST_TIME) {
    $expirydate = variable_get(USERPOINTS_EXPIREAFTER_DATE, 0);
    if ($expirydate) {
      $expirydate = REQUEST_TIME + $expirydate;
    }
  }
  return (int) $expirydate;
}

/**
 * Implements hook_user_delete().
 */
function userpoints_user_delete($account) {
  // The user is being deleted, delete all traces in userpoints and txn tables.
  db_delete('userpoints')
          ->condition('uid', $account->uid)
          ->execute();
  db_delete('userpoints_txn')
          ->condition('uid', $account->uid)
          ->execute();
}

/**
 * Implements hook_user_view().
 */
function userpoints_user_view($account, $view_mode) {
  global $user;
  if (user_access('view userpoints') || (user_access('view own userpoints') && $user->uid == $account->uid)) {
    $points_list = userpoints_get_points_list($account);

    if (!empty($details) || $points_list) {
      $account->content['userpoints'] = array(
        'title' => array(
          '#markup' => '<h3>' .  t('!Points', userpoints_translation()) . '</h3>',
        ),
        '#weight' => 0,
      );
      if ($points_list) {
        $account->content['userpoints'] += $points_list;
      }
    }
  }
}

/**
 * Implements hook_field_extra_fields().
 */
function userpoints_field_extra_fields() {
  $extra['user']['user'] = array(
    'display' => array(
      'userpoints' => array(
        'label' => t('!Points', userpoints_translation()),
        'description' => t('!Points related information and actions.', userpoints_translation()),
        'weight' => 0,
      )
    )
  );
  return $extra;
}

/**
 * Returns a render array that displays the points and action links.
 *
 * @param $account
 *   User object for which the points should be displayed.
 * @return
 *   Render array with the points and actions.
 */
function userpoints_get_points_list($account = NULL) {
  global $user;
  if (empty($account)) {
    $account = $user;
  }
  $output = array();

  $categories = userpoints_get_categories();
  // 0 can not be used as a checkbox value.
  $categories = array('uncategorized' => $categories[0]) + $categories + array('all' => t('Total !points in all categories', userpoints_translation()));
  unset($categories[0]);
  $tids = array_filter(variable_get(USERPOINTS_CATEGORY_PROFILE_DISPLAY_TID, array_keys($categories)));
  if (!empty($tids)) {
    $points_list = array();
    $total = NULL;
    foreach ($tids as $tid) {
      // Which points are we displaying. Special case for uncategorized.
      $points = userpoints_get_current_points($account->uid, $tid == 'uncategorized' ? 0 : $tid);
      if ($tid == 'all') {
        $total = t('Total (all categories): @points', userpoints_translation() + array('@points' => $points));
      }
      else {
        $points_list[] = t('%category: @points', userpoints_translation() + array('@points' => $points, '%category' => $categories[$tid]));
      }
    }

    // If there are multiple categories, create a list.
    $output['list'] = array(
      '#theme' => 'item_list',
      '#items' => $points_list,
      '#attributes' => array('class' => array('userpoints-points')),
    );

    if ($total) {
      $output['total'] = array(
        '#markup' => '<div class="userpoints-total">' . $total . '</div>',
      );
    }
  }

  $links = array();
  if (userpoints_access_my_points($account)) {
    $links['userpoints-view'] = array(
      'title' => t('View !points transactions', userpoints_translation()),
      'href' => $user->uid == $account->uid ? 'myuserpoints' : 'user/' . $account->uid . '/points',
    );
  }
  if (userpoints_admin_access('add')) {
    $links['userpoints-adjust'] = array(
      'title' => t('Add or deduct !points', userpoints_translation()),
      'href' => 'admin/config/people/userpoints/add/' . $account->uid,
    );
  }
  $output['actions'] = array(
    '#theme' => 'links__userpoints_actions',
    '#links' => $links,
    '#attributes' => array('class' => array('links', 'userpoints-links')),
    '#attached' => array(
      'css' => array(drupal_get_path('module', 'userpoints') . '/userpoints.css'),
    ),
  );

  return $output;
}

/**
 * Provides a dropdown to filter by category.
 */
function userpoints_filter_form($account = NULL, $values = array()) {
  $categories = userpoints_get_categories($account);
  $form = array();
  if (count($categories) > 1) {
    $categories = array('all' => t('Display all')) + $categories;
    $form['tid'] = array(
      '#type' => 'select',
      '#title' => t('Filter by category'),
      '#options' => $categories,
      '#default_value' => isset($values['tid']) ? $values['tid'] : 'all',
      '#ajax' => array(
        'callback' => 'userpoints_filter_form_ajax_callback',
        'wrapper' => 'userpoints_list_wrapper',
      ),
    );
  }

  return $form;
}

/**
 * Ajax callback for userpoints filter form.
 */
function userpoints_filter_form_ajax_callback($form, $form_state) {
  $commands = array();
  // First, replace the points listing.
  $commands[] = ajax_command_replace('#userpoints_list_wrapper', drupal_render($form['list']));

  // Bartik uses the page-title id, Seven has a class of that name. Replace
  // the title for both of them and assume that most other themes use the
  // same.
  $commands[] = ajax_command_html('h1#page-title, h1.page-title', drupal_get_title());

  return array('#type' => 'ajax', '#commands' => $commands);
}

/**
 * Parse input and generate an values array.
 *
 * @param $form_state
 *   Form state with the submitted values.
 * @param $tid
 *   Category id to be used as a default.
 *
 * @return
 *   Array of values to be used with userpoints_filter_form().
 */
function userpoints_filter_parse_input($form_state, $tid = NULL) {
  // Enforce tid if passed in through the URL.
  $values = isset($form_state['values']) ? $form_state['values'] : array('tid' => NULL);
  if (!isset($values['tid'])) {
    if (isset($_GET['tid'])) {
      $values['tid'] = $_GET['tid'];
    }
    elseif ($tid) {
      $values['tid'] = $tid;
    }
  }

  if (isset($values['tid'])) {
    // Add tid argument to GET.
    $_GET['tid'] = $values['tid'];
  }

  return $values;
}

/**
 * Filter a query according to the selected filters.
 */
function userpoints_filter_query(SelectQueryInterface $query, $values) {
    // Check for filtering. isset() is used because 0 is a valid value
  // (Uncategorized).
  if (isset($values['tid']) && $values['tid'] != 'all') {
    // If a category is selected, limit both the default query and the query
    // that displays pending points to this category.
    $query->condition('p.tid', (int)$values['tid']);
    $categories = userpoints_get_categories();
    return $categories[$values['tid']];
  }
}

/**
 * Implements hook_block_info().
 */
function userpoints_block_info() {
  $blocks[-1]['info'] = t('User\'s !points', userpoints_translation());
  // Grab a list of the available terms.
  $terms = userpoints_get_categories();
  foreach ($terms as $key => $value) {
    $blocks[$key]['info'] = t("Highest @term !points", userpoints_translation() + array('@term' => $value));
    ;
  }

  return $blocks;
}

/**
 * Implements hook_block_view().
 */
function userpoints_block_view($delta) {
  global $user;
  if ($delta == -1 && (user_access('view userpoints') || user_access('view own userpoints'))) {
    $title = t('My !points balance', userpoints_translation());
    if ($user->uid) {
      $content = userpoints_get_points_list();
    }
    else {
      $content = t('!Points are visible to logged in users only', userpoints_translation());
    }
  }
  elseif (user_access('view userpoints')) {
    // $delta is our tid for pulling the points.
    // If 0 we pull 0 or NULL.
    $title = t('Highest Users');

    $query = db_select('userpoints', 'p')
                    ->fields('p', array('uid', 'points'))
                    ->orderBy('p.points', 'DESC')
                    ->range(0, variable_get('userpoints_block_up_records_' . $delta, 5));
    if ($delta == 0) {
      $query->condition(db_or()->condition('p.tid', 0)->isNull('p.tid'));
    }
    else {
      $query->condition('p.tid', $delta);
    }

    // Exclude blocked users.
    $query->join('users', 'u', 'u.uid = p.uid AND u.status = 1');

    $rows = array();
    foreach ($query->execute() as $data) {
      $rows[] =
              array(
                  array('data' => theme('username', array('account' => user_load($data->uid)))),
                  array('data' => $data->points, 'align' => 'right'));
    }
    $header = array(t('User'), t('!Points', userpoints_translation()));
    $content = theme('table', array('header' => $header, 'rows' => $rows));
    $content .= '<div class="more-link">' . l(t('more'), 'userpoints/' . $delta, array('attributes' => array('title' => t('All users by !points', userpoints_translation())))) . '</div>';
  }

  if (!empty($title) && !empty($content)) {
    $block['subject'] = $title;
    $block['content'] = $content;
    return $block;
  }
}

/**
 * Implements hook_block_configure().
 */
function userpoints_block_configure($delta) {
  if ($delta > 1) {
    $form['up_records'] = array(
        '#type' => 'select',
        '#title' => t('Number of users to display'),
        '#default_value' => variable_get('userpoints_block_up_records_' . $delta, 10),
        '#options' => array(
            1 => 1, 5 => 5, 10 => 10, 15 => 15, 20 => 20,
            30 => 30, 40 => 40, 50 => 50, 60 => 60,
            70 => 70, 80 => 80, 90 => 90, 100 => 100, 200 => 200,
        ),
        '#description' => t('Limit the number of users displayed to this value'),
    );
    return $form;
  }
}

/**
 * Implements hook_block_save().
 */
function userpoints_block_save($delta, $edit) {
  variable_set('userpoints_block_up_records_' . $delta, isset($edit['up_records']) ? $edit['up_records'] : 10);
}

/**
 * returns an array of possible expiry times
 * to the administrative settings page
 */
function userpoints_expiry_dates() {
  return array(
      NULL => 'Never',
      3600 => 'One hour',
      86400 => 'One Day',
      604800 => 'One Week',
      1209600 => 'Two Weeks',
      2419200 => 'Four Weeks',
      31536000 => '365 Days',
  );
}

/**
 * Modifies FAPI date setting to timestamp.
 *
 * @return
 *   UNIX timestamp.
 */
function userpoints_date_to_timestamp($date) {
  //This takes the FAPI date form array and returns a timestamp
  if ($date) {
    return mktime(0, 0, 0, $date['month'], $date['day'], $date['year']);
  }
}

/**
 * Finds and expires expired points.
 *
 * Finds all transactions with a expirydate < REQUEST_TIME and posts
 * opposite transactions (sum of 0).
 */
function userpoints_expire_transactions() {
  $sql = "SELECT txn_id
          FROM {userpoints_txn}
          WHERE status = 0 AND expired = 0
          AND (expirydate < :expiry_date AND expirydate != 0)";
  $txn_ids = db_query($sql, array(':expiry_date' => REQUEST_TIME))->fetchCol();
  foreach (userpoints_transaction_load_multiple($txn_ids) as $transaction) {
    $time_stamp_formatted = format_date($transaction->time_stamp, 'custom', 'Y-m-d H:i');
    $arguments = array_merge(userpoints_translation(), array(
      '!operation' => $transaction->operation,
      '!description' => $transaction->description,
      '!txn_id' => $transaction->txn_id,
      '!date' => $time_stamp_formatted,
    ));
    $description = strtr(variable_get(USERPOINTS_EXPIRY_DESCRIPTION, NULL), $arguments);

    userpoints_grant_points('expiry', -$transaction->points, $transaction->uid)
      ->setDescription($description)
      ->setParent($transaction->txn_id)
      ->setTid($transaction->tid)
      ->setExpirationDate(0)
      ->save();

    // Ok we've expired the entry, now the original transaction needs to be
    // marked as expired.
    $transaction
      ->setExpired(1)
      ->save();
  }
}

/**
 * Implements hook_cron().
 */
function userpoints_cron() {
  userpoints_expire_transactions();
}


/**
 *  Returns the Vocabulary ID (vid) used by userpoints for categorization.
 *
 *  If no vocab exists it will create one.
 */
function userpoints_get_vid() {
  if (!module_exists('taxonomy')) {
    return FALSE;
  }
  // Code lovingly inspired by the image.module w/ code by drewish.
  $vid = variable_get(USERPOINTS_CATEGORY_DEFAULT_VID, '');
  if (empty($vid) || !taxonomy_vocabulary_load($vid)) {
    $sql = "SELECT vid FROM {taxonomy_vocabulary} WHERE module='userpoints'";
    $vid = db_query($sql)->fetchField();
    if (!$vid) {
      drupal_set_message(t("Created Userpoints vocabulary"));
      // No vocabulary exists, we'll create one.
      $vocab = (object) array(
          'name' => USERPOINTS_CATEGORY_NAME,
          'description' => t('Automatically created by the userpoints module'),
          'machine_name' => 'userpoints',
          'multiple' => '0',
          'required' => '0',
          'hierarchy' => '1',
          'relations' => '0',
          'module' => 'userpoints',
      );
      taxonomy_vocabulary_save($vocab);
      $vid = $vocab->vid;
    }
    variable_set(USERPOINTS_CATEGORY_DEFAULT_VID, $vid);
  }
  if (!is_numeric($vid)) {
    watchdog('userpoints', 'userpoints module was unable to select or create a vocabulary. !Points will be uncategorized', array(), WATCHDOG_ERROR);
  }
  return $vid;
}

/**
 * Returns an array of possible categories, suitable for inclusion in FAPI.
 *
 * @ingroup userpoints_api
 */
function userpoints_get_categories($account = NULL) {
  $cache = drupal_static(__FUNCTION__, array());
  $key = $account ? $account->uid : 0;
  if (!isset($cache[$key])) {
    // Create the "Uncategorized" category.
    $options = array();
    $options[0] = t('!Uncategorized', userpoints_translation());
    if (module_exists('taxonomy')) {
      $vid = userpoints_get_vid();
      if ($vid) {
        // If an account is passed, load the terms directly from the database.
        if ($account) {
          $query = db_select('taxonomy_term_data', 't')
            ->fields('t', array('tid', 'name'))
            ->condition('t.vid', userpoints_get_vid())
            ->groupBy('t.tid')
            ->groupBy('t.name')
            ->orderBy('t.weight');
          $query->join('userpoints_txn', 'p', 't.tid = p.tid AND p.uid = :uid', array(':uid' => $account->uid));
          $terms = $query->execute();
        }
        else {
          $terms = taxonomy_get_tree($vid);
        }
        foreach ($terms as $term) {
          $options[$term->tid] = $term->name;
        }
      }
    }
    $cache[$key] = $options;
  }
  return $cache[$key];
}

/**
 * Wrapper function to return the default tid via API call
 */
function userpoints_get_default_tid() {
  return (int) variable_get(USERPOINTS_CATEGORY_DEFAULT_TID, 0);
}


/**
 * Implements hook_views_api().
 */
function userpoints_views_api() {
  return array(
      'api' => 2.0,
  );
}

/**
 * Returns information about point-providing modules and operations.
 *
 * @see hook_userpoints_info()
 */
function userpoints_get_info($operation = NULL) {
  static $info = NULL;

  if (!isset($info)) {
    // Collect information.
    $info = module_invoke_all('userpoints_info');

    // Allow other modules to alter that information.
    drupal_alter('userpoints_info', $info);
  }

  if ($operation) {
    if (isset($info[$operation])) {
      return $info[$operation];
    }
    return NULL;
  }
  return $info;
}

/**
 * Implements hook_userpoints_info().
 */
function userpoints_userpoints_info() {
  return array(
    'expiry' => array(
      'description' => t('!Points have expired.', userpoints_translation()),
      'admin description' => t('Expire an existing transaction'),
    )
  );
}

/**
 * Load a userpoints transaction.
 *
 * @param $txn_id
 *   Userpoints transaction Id.
 *
 * @return UserpointsTransaction
 *   A loaded userpoints transaction object.
 */
function userpoints_transaction_load($txn_id, $reset = FALSE) {
  $txn_ids = (isset($txn_id) ? array($txn_id) : array());
  $temp = userpoints_transaction_load_multiple($txn_ids, array(), $reset);
  return $temp ? reset($temp) : FALSE;
}

function userpoints_transaction_load_multiple(array $txn_ids, $conditions = array(), $reset = FALSE) {
  return entity_load('userpoints_transaction', $txn_ids, $conditions, $reset);
}

/**
 * Returns a table header for a transaction listing.
 *
 * @param $settings
 *   Array with settings about which column shall be displayed. All settings
 *   default to TRUE.
 *   - show_category, show category column.
 *   - show_user, show user column.
 *   - show_status, show status column.
 * @return
 *   Table header definition for theme_table() and TableSort.
 */
function userpoints_get_transaction_header($settings) {
  $settings += array(
    'show_category' => count(userpoints_get_categories()) > 1,
    'show_user' => TRUE,
    'show_status' => TRUE,
  );
  $header = array();
  if ($settings['show_user']) {
    $header[] = array('data' => t('User'), 'field' => 'uid', 'class' => array('userpoints-transactions-header-status'));
  }
  $header[] = array('data' => t('!Points', userpoints_translation()), 'field' => 'points', 'class' => array('userpoints-transactions-header-points'));
  // Only display category if there is more than one category. In contrast to
  // the filter, this is not specific for the categories. If there are
  // categories, we want tell the user in which he has points, even if he
  // only has points in a single category.
  if ($settings['show_category']) {
    $header[] = array('data' => t('Category'), 'field' => 't.name', 'class' => array('userpoints-transactions-header-category'));
  }
  $header[] = array('data' => t('Date'), 'field' => 'time_stamp', 'sort' => 'desc', 'class' => array('userpoints-transactions-header-timestamp'));
  $header[] = array('data' => t('Reason'), 'class' => array('userpoints-transactions-header-reason'));
  if ($settings['show_status']) {
    $header[] = array('data' => t('Status'), 'field' => 'status', 'class' => array('userpoints-transactions-header-status'));
  }
  $header[] = array('data' => t('Actions'), 'class' => array('userpoints-transactions-header-actions'));
  return $header;
}

/**
 * Returns the header array definition for userpoints listings.
 */
function userpoints_get_list_header() {
  $header = array(
    array('data' => t('User'), 'field' => 'u.name'),
  );
  if (count(userpoints_get_categories()) > 1) {
    $header[] = array('data' => t('Category'), 'field' => 't.name');
  }
  $header[] = array('data' => t('!Points', userpoints_translation()), 'field' => 'p.points', 'sort' => 'desc');
  return $header;
}

function userpoints_get_list_row($data) {
  global $user;

  $categories = userpoints_get_categories();

  $details = '';
  if ($user->uid == $data->uid) {
    $details = "&nbsp;&nbsp;" . l(t("details"), 'myuserpoints');
  }
  else if (userpoints_admin_access('edit')) {
    $details = "&nbsp;&nbsp;" . l(t("details"), 'user/' . $data->uid . '/points');
  }

  $name = theme('username', array('account' => $data));
  $row = array(
    array('data' => $details ? t('!name (!details)', array('!name' => $name, '!details' => $details)) : $name),
  );
  if (count($categories) > 1) {
    $row[] = array('data' => isset($categories[$data->tid]) ? $categories[$data->tid] : $categories[0], 'align' => 'right');
  }
  $row[] = array('data' => $data->points, 'align' => 'right');
  return $row;
}

/**
 * Implements hook_entity_property_info().
 */
function userpoints_entity_property_info() {
  $info = array();
  // Add meta-data about the basic userpoints_transaction properties.
  $properties = &$info['userpoints_transaction']['properties'];
  $properties = array(
    'user' => array(
      'type' => 'user',
      'label' => t('User'),
      'description' => t('The user that will receive the !points', userpoints_translation()),
      'setter callback' => 'entity_property_verbatim_set',
    ),
    'points' => array(
      'type' => 'integer',
      'label' => t('!Points', userpoints_translation()),
      'description' => t('Amount of !points to give or take.', userpoints_translation()),
      'restriction' => 'input',
      'setter callback' => 'entity_property_verbatim_set',
    ),
    'points_abs' => array(
      'label' => t('!Points absolute', userpoints_translation()),
      'description' => t('The absolute (positive) amount of !points of this transaction.', userpoints_translation()),
      'type' => 'integer',
      'getter callback' => 'userpoints_transaction_get_points_absolute',
    ),
    'tid' => array(
      'label' => t('!Points category', userpoints_translation()),
      'description' => t('The category to which these transaction belongs.'),
      'type' => 'integer',
      'options list' => 'userpoints_rules_get_categories',
      'restriction' => 'input',
      'setter callback' => 'entity_property_verbatim_set',
    ),
    'entity' => array(
      'label' => t('Entity'),
      'type' => 'entity',
      'description' => t('The entity to which this transaction refers.'),
      'restriction' => 'input',
      'optional' => TRUE,
      'getter callback' => 'entity_property_verbatim_get',
     ),
    'description' => array(
      'label' => t('Description'),
      'type' => 'text',
      'description' => t('Can contain the reason why the points have been given.'),
      'restriction' => 'input',
      'optional' => TRUE,
      'setter callback' => 'entity_property_verbatim_set',
    ),
    'reference' => array(
      'label' => t('Reference'),
      'type' => 'text',
      'description' => t('Can contain a reference for this transaction.'),
      'optional' => TRUE,
      'setter callback' => 'entity_property_verbatim_set',
    ),
    'operation' => array(
      'label' => t('Operation'),
      'type' => 'text',
      'description' => t('Describes the operation (Insert/Remove/...).'),
      'restriction' => 'input',
      'setter callback' => 'entity_property_verbatim_set',
    ),
    'reason' => array(
      'label' => t('Reason'),
      'type' => 'text',
      'description' => t('The reason why the points were granted.'),
      'restriction' => 'input',
    ),
    'time_stamp' => array(
      'label' => t('Timestamp'),
      'type' => 'date',
      'description' => t('Time when the points were given.'),
      'setter callback' => 'entity_property_verbatim_set',
      'getter callback' => 'entity_property_verbatim_get',
    ),
    'expirydate' => array(
      'label' => t('Expiry date'),
      'type' => 'date',
      'description' => t('Time when the points will expire.'),
      'setter callback' => 'entity_property_verbatim_set',
      'getter callback' => 'entity_property_verbatim_get',
    ),
    'display' => array(
      'label' => t('Display'),
      'type' => 'boolean',
      'description' => t('Whether to show a message to the user for this transaction or not.'),
      'setter callback' => 'entity_property_verbatim_set',
    ),
    'status' => array(
      'label' => t('Status'),
      'type' => 'integer',
      'description' => t('Status of this transaction.'),
      'options list' => 'userpoints_txn_status',
      'setter callback' => 'entity_property_verbatim_set',
      'getter callback' => 'entity_property_verbatim_get',
    ),
  );
  return $info;
}

/**
 * Gets the absolute points from a transaction..
 */
function userpoints_transaction_get_points_absolute($userpoints_transaction, array $options, $name) {
  if (is_object($userpoints_transaction)) {
    return abs($userpoints_transaction->points);
  }
  return NULL;
}


/**
 * Implements hook_entity_info().
 */
function userpoints_entity_info() {
  $return = array(
    'userpoints_transaction' => array(
      'label' => t('Userpoints Transaction'),
      'controller class' => 'UserpointsTransactionController',
      'base table' => 'userpoints_txn',
      'uri callback' => 'userpoints_transaction_uri_callback',
      'fieldable' => FALSE,
      'entity keys' => array(
        'id' => 'txn_id',
      ),
      'bundles' => array(),
      'view modes' => array(
        'full' => array(
          'label' => t('Full content'),
          'custom settings' => FALSE,
        ),
      ),
    ),
  );
  return $return;
}

/**
 * Return the path to the correct view location based on the global context.
 *
 * @param $transaction
 *   The userpoints transaction entity.
 * @param bool $prefix_only
 *   If only the url prefix (without /view suffix) should be returned. Defaults to FALSE.
 *
 * @return
 *   An array with the keys path and options.
 */
function userpoints_transaction_uri_callback($transaction, $prefix_only = FALSE) {
  global $user;
  $uri = array(
    // Default path is displaying it below myuserpoints for the current user.
    'path' => 'myuserpoints/transaction/' . $transaction->txn_id,
    'options' => array(),
  );
  // When viewing the transaction in the admin UI (but not the add points page, as this might be called for generating
  // tokens), use the admin link.
  if (strpos($_GET['q'], 'admin/config/people/userpoints') !== FALSE && strpos($_GET['q'], 'admin/config/people/userpoints/add') === FALSE ) {
    $uri['path'] = "admin/config/people/userpoints/transaction/$transaction->txn_id";
  }
  elseif ($transaction->uid != $user->uid) {
    // When not in the admin ui but viewing the transaction of someone else, use the path for another user.
    $uri['path'] = "user/$transaction->uid/points/$transaction->txn_id";
  }

  if (!$prefix_only) {
    $uri['path'] .= '/view';
  }

  return $uri;
}

/**
 * Userpoints transaction controller.
 */
class UserpointsTransactionController extends DrupalDefaultEntityController {
    
  /**
   * Overrides DrupalDefaultEntityController::load().
   */
  public function load($ids = array(), $conditions = array()) {
    $entities = array();

    // Revisions are not statically cached, and require a different query to
    // other conditions, so separate the revision id into its own variable.
    if ($this->revisionKey && isset($conditions[$this->revisionKey])) {
      $revision_id = $conditions[$this->revisionKey];
      unset($conditions[$this->revisionKey]);
    }
    else {
      $revision_id = FALSE;
    }

    // Create a new variable which is either a prepared version of the $ids
    // array for later comparison with the entity cache, or FALSE if no $ids
    // were passed. The $ids array is reduced as items are loaded from cache,
    // and we need to know if it's empty for this reason to avoid querying the
    // database when all requested entities are loaded from cache.
    $passed_ids = !empty($ids) ? array_flip($ids) : FALSE;
    // Try to load entities from the static cache, if the entity type supports
    // static caching.
    if ($this->cache && !$revision_id) {
      $entities += $this->cacheGet($ids, $conditions);
      // If any entities were loaded, remove them from the ids still to load.
      if ($passed_ids) {
        $ids = array_keys(array_diff_key($passed_ids, $entities));
      }
    }

    // Load any remaining entities from the database. This is the case if $ids
    // is set to FALSE (so we load all entities), if there are any ids left to
    // load, if loading a revision, or if $conditions was passed without $ids.
    if ($ids === FALSE || $ids || $revision_id || ($conditions && !$passed_ids)) {
      // Build the query.
      $query = $this->buildQuery($ids, $conditions, $revision_id);
      $queried_entities = array();
      $result = $query->execute();
      foreach ($result->fetchAllAssoc($this->idKey, PDO::FETCH_ASSOC) as $row) {
        $queried_entities[$row[$this->idKey]] = new UserpointsTransaction($row);
      }
    }

    // Pass all entities loaded from the database through $this->attachLoad(),
    // which attaches fields (if supported by the entity type) and calls the
    // entity type specific load callback, for example hook_node_load().
    if (!empty($queried_entities)) {
      $this->attachLoad($queried_entities, $revision_id);
      $entities += $queried_entities;
    }

    if ($this->cache) {
      // Add entities to the cache if we are not loading a revision.
      if (!empty($queried_entities) && !$revision_id) {
        $this->cacheSet($queried_entities);
      }
    }

    // Ensure that the returned array is ordered the same as the original
    // $ids array if this was passed in and remove any invalid ids.
    if ($passed_ids) {
      // Remove any invalid ids from the array.
      $passed_ids = array_intersect_key($passed_ids, $entities);
      foreach ($entities as $entity) {
        $passed_ids[$entity->{$this->idKey}] = $entity;
      }
      $entities = $passed_ids;
    }

    return $entities;
  }
}
