<?php

// $Id$
// Copyright 2005-2007 Khalid Baheyeldin http://2bits.com
define('USERPOINTS_TRANS_UCPOINTS', 'userpoints_trans_ucpoints');
define('USERPOINTS_TRANS_LCPOINTS', 'userpoints_trans_lcpoints');
define('USERPOINTS_TRANS_UCPOINT', 'userpoints_trans_ucpoint');
define('USERPOINTS_TRANS_LCPOINT', 'userpoints_trans_lcpoint');
define('USERPOINTS_TRANS_UNCAT', 'userpoints_trans_uncat');

define('USERPOINTS_STATUS', 'userpoints_status');

define('USERPOINTS_POINTS_MODERATION', 'userpoints_points_moderation');

define('USERPOINTS_TXN_STATUS_APPROVED', 0);
define('USERPOINTS_TXN_STATUS_PENDING', 1);
define('USERPOINTS_TXN_STATUS_DECLINED', 2);


define('USERPOINTS_EXPIRY_DESCRIPTION', 'userpoints_expiry_description');
define('USERPOINTS_EXPIREON_DATE', 'userpoints_expireon_date');
define('USERPOINTS_EXPIREAFTER_DATE', 'userpoints_expireafter_date');
define('USERPOINTS_DISPLAY_MESSAGE', 'userpoints_display_message');

define('USERPOINTS_REPORT_USERCOUNT', 'userpoints_report_usercount');
define('USERPOINTS_REPORT_LIMIT', 'userpoints_report_limit');
define('USERPOINTS_REPORT_DISPLAYZERO', 'userpoints_report_displayzero');

define('USERPOINTS_CATEGORY_NAME', 'Userpoints');
define('USERPOINTS_CATEGORY_DEFAULT_VID', 'userpoints_category_default_vid');
define('USERPOINTS_CATEGORY_DEFAULT_TID', 'userpoints_category_default_tid');
define('USERPOINTS_CATEGORY_PROFILE_DISPLAY_TID', 'userpoints_category_profile_display_tid');
define('USERPOINTS_TRANSACTION_TIMESTAMP', 'userpoints_transaction_timestamp');

/**
 * Returns an array of common translation placeholders.
 */
function userpoints_translation() {
  static $trans;

  if (!isset($trans)) {
    $trans = array(
        '!Points' => variable_get(USERPOINTS_TRANS_UCPOINTS, 'Points'),
        '!points' => variable_get(USERPOINTS_TRANS_LCPOINTS, 'points'),
        '!Point' => variable_get(USERPOINTS_TRANS_UCPOINT, 'Point'),
        '!point' => variable_get(USERPOINTS_TRANS_LCPOINT, 'point'),
        '!Uncategorized' => variable_get(USERPOINTS_TRANS_UNCAT, 'General'),
    );
  }
  return $trans;
}

/*
 * Returns an array of possible transaction statuses.
 */

function userpoints_txn_status() {
  return array(
      USERPOINTS_TXN_STATUS_APPROVED => t('Approved'),
      USERPOINTS_TXN_STATUS_PENDING => t('Pending'),
      USERPOINTS_TXN_STATUS_DECLINED => t('Declined'),
  );
}

/**
 * Implements hook_help().
 */
function userpoints_help($path, $arg) {
  switch ($path) {
    case 'admin/settings/userpoints':
      return t('Configure userpoints moderation and branding translation');
    case 'admin/help#userpoints':
      return t('Users earn !points as they post nodes, comments, and vote on nodes', userpoints_translation());
  }
}

/**
 * Implements hook_menu().
 */
function userpoints_menu() {
  $items = array();
  $items['admin/config/people/userpoints'] = array(
      'title' => '!Points',
      'title arguments' => userpoints_translation(),
      'description' => strtr('Manage !points', userpoints_translation()),
      'page callback' => 'userpoints_admin_points',
      'access arguments' => array('administer userpoints'),
      'file' => 'userpoints.admin.inc',
  );
  $items['admin/config/people/userpoints/list'] = array(
      'title' => 'List',
      'title arguments' => userpoints_translation(),
      'description' => strtr('List users by !points', userpoints_translation()),
      'access arguments' => array('view userpoints'),
      'file' => 'userpoints.admin.inc',
      'type' => MENU_DEFAULT_LOCAL_TASK,
      'weight' => -2,
  );
  $items['admin/config/people/userpoints/moderate'] = array(
      'title' => 'Moderation',
      'title arguments' => userpoints_translation(),
      'description' => strtr('Review !points in moderation', userpoints_translation()),
      'page callback' => 'userpoints_admin_manage',
      'access arguments' => array('administer userpoints'),
      'file' => 'userpoints.admin.inc',
      'type' => MENU_LOCAL_TASK,
      'weight' => -1,
  );
  $items['admin/config/people/userpoints/add'] = array(
      'title' => 'Add',
      'description' => 'Admin add/delete userpoints',
      'page callback' => 'drupal_get_form',
      'page arguments' => array('userpoints_admin_txn', 4, 5),
      'access arguments' => array('administer userpoints'),
      'file' => 'userpoints.admin.inc',
      'type' => MENU_LOCAL_TASK,
      'weight' => 0,
  );
  $items['admin/config/people/userpoints/edit'] = array(
      'title' => 'Edit',
      'page callback' => 'drupal_get_form',
      'page arguments' => array('userpoints_admin_txn', 4, 5),
      'access arguments' => array('administer userpoints'),
      'file' => 'userpoints.admin.inc',
      'type' => MENU_CALLBACK
  );

  $items['admin/config/people/userpoints/approve'] = array(
      'title' => 'Approve Userpoints',
      'page callback' => 'userpoints_admin_approve',
      'page arguments' => array(4, 5),
      'access arguments' => array('administer userpoints'),
      'file' => 'userpoints.admin.inc',
      'type' => MENU_CALLBACK
  );
  $items['admin/config/people/userpoints/decline'] = array(
      'title' => 'Approve !points',
      'title arguments' => userpoints_translation(),
      'page callback' => 'userpoints_admin_approve',
      'page arguments' => array(4, 5),
      'access arguments' => array('administer userpoints'),
      'file' => 'userpoints.admin.inc',
      'type' => MENU_CALLBACK
  );

  $items['admin/config/people/userpoints/settings'] = array(
      'title' => '!Points settings',
      'description' => strtr('Settings for !points', userpoints_translation()),
      'title arguments' => userpoints_translation(),
      'page callback' => 'drupal_get_form',
      'page arguments' => array('userpoints_admin_settings'),
      'access arguments' => array('administer userpoints'),
      'file' => 'userpoints.admin.inc',
      'type' => MENU_LOCAL_TASK,
      'weight' => 10,
  );

  $items['userpoints'] = array(
      'title' => 'Users by !points',
      'title arguments' => userpoints_translation(),
      'page callback' => 'userpoints_list_users',
      'access arguments' => array('view userpoints'),
      'file' => 'userpoints.pages.inc',
      'type' => MENU_NORMAL_ITEM,
  );

  $items['myuserpoints/%user_uid_only_optional'] = array(
      'title' => 'My !points',
      'title arguments' => userpoints_translation(),
      'page callback' => 'userpoints_list_my_userpoints',
      'page arguments' => array(1),
      'access callback' => 'userpoints_access_my_points',
      'access arguments' => array(1),
      'file' => 'userpoints.pages.inc',
      'type' => MENU_NORMAL_ITEM,
      'menu_name' => 'user-menu',
  );
  return $items;
}

/**
 * Checks if user can access their points - used via hook_menu().
 *
 * @return
 *   TRUE if user has permissions to view userpoints and if the user is logged
 *   in.
 */
function userpoints_access_my_points($uid = NULL) {
  global $user;
  if ($user->uid != $uid) {
    return user_access('administer userpoints');
  }
  return (user_access('view userpoints') && user_is_logged_in()) || user_access('view own userpoints');
}

/**
 * Implements hook_perm().
 */
function userpoints_permission() {
  return array(
    'view userpoints' => array(
      'title' => t('View all UserPoints'),
    ),
    'view own userpoints' => array(
      'title' => t('View own UserPoints'),
    ),
    'administer userpoints' => array(
      'title' => t('Administer Userpoints')
  ));
}

/**
 * Implements hook_theme().
 */
function userpoints_theme() {
  return array(
      'userpoints_list_users' => array(
          'variables' => array(
              'header' => NULL,
              'rows' => NULL,
              'tid' => NULL,
              'pager_limit' => NULL,
          ),
          'file' => 'userpoints.theme.inc',
      ),
      'userpoints_list_users_header' => array(
          'variables' => array(),
          'file' => 'userpoints.theme.inc',
      ),
      'userpoints_list_users_row' => array(
          'variables' => array(
              'row' => NULL,
          ),
          'file' => 'userpoints.theme.inc',
      ),
      'userpoints_list_my_userpoints' => array(
          'variables' => array(
              'args' => NULL,
              'header' => NULL,
              'rows' => NULL,
          ),
          'file' => 'userpoints.theme.inc',
      ),
  );
}

/**
 * Implements hook_tokens().
 */
function userpoints_tokens($type, $tokens, array $data = array(), array $options = array()) {
  if ($type == 'user' && isset($data['user']) && isset($tokens['userpoints'])) {
    return array($tokens['userpoints'] => userpoints_get_current_points($data['user']->uid));
  }
}

/**
 * Implements hook_token_list().
 */
function userpoints_token_list($type = 'all') {
  return array(
      'tokens' => array(
          'user' => array(
              'name' => t('User points'),
              'description' => t('The number of points a user has.'),
          )
      )
  );
}

/**
 * Get current points of a user.
 *
 * @param $uid
 *   User id of the user to get or lose the points.
 *
 * @return
 *   Number of current points in that user's account.
 */
function userpoints_get_current_points($uid = NULL, $tid = NULL) {
  if (!$uid) {
    global $user;
    $uid = $user->uid;
  }
  if (!$tid) {
    $tid = userpoints_get_default_tid();
  }
  elseif ($tid == 'all') {
    return (int) db_query('SELECT SUM(points) FROM {userpoints} WHERE uid = :uid', array(':uid' => $uid))->fetchField();
  }
  return (int) db_query('SELECT points FROM {userpoints} WHERE uid = :uid AND tid = :tid', array(':uid' => $uid, ':tid' => $tid))->fetchField();
}

/**
 * Gets the number of maximal points of that user.
 *
 * @param $uid
 *   User id of the user to get or lose the points.
 *
 * @return
 *   Number of max points in that user's account.
 */
function userpoints_get_max_points($uid = NULL, $tid = NULL) {
  $max = drupal_static(__FUNCTION__, array());

  // Check if uid is passed as a parameter.
  if (!$uid) {
    // It is not, so we use the currently logged in user's uid.
    global $user;
    $uid = $user->uid;
  }

  // Check if a term id is passed as a parameter.
  if (!$tid) {
    // It is not, so get the default term id.
    $tid = userpoints_get_default_tid();
  }

  // Check if we have already cached the maximum for the user/term combination on previous calls.
  if (!isset($max[$uid][$tid])) {
    // We did not cache it.
    if ($tid == 'all') {
      // There is no term id, so we use "all".
      $max[$uid][$tid] = db_query('SELECT SUM(max_points) FROM {userpoints} WHERE uid = :uid', array(':uid' => $uid))->fetchField();
    }
    else {
      // A term ID is specified, so fetch its maximum points.
      $max[$uid][$tid] = db_query('SELECT max_points FROM {userpoints} WHERE uid = :uid AND tid = :tid', array(':uid' => $uid, ':tid' => $tid))->fetchField();
    }
  }
  // Return the cached value.
  return $max[$uid][$tid];
}

/**
 * Save userpoint changes and call hooks.
 *
 * @param $params
 *    if (int) assumed to be points for current user
 *    Accepts an array of keyed variables and parameters
 *    'points' => # of points (int) (required)
 *    'moderate' => TRUE/FALSE
 *    'uid' => $user->uid
 *    'time_stamp' => unix time of the points assignement date
 *    'operation' => 'published' 'moderated' etc.
 *    'tid' => 'category ID'
 *    'expirydate' => timestamp or 0, 0 = non-expiring; NULL = site default
 *    'description' => 'description'
 *    'reference' => reserved for module specific use
 *    'display' => whether or not to display "points awarded" message
 *    'txn_id' => Transaction ID of points, If present an UPDATE is performed
 *    'entity_id' => ID of an entity in the Database. ex. $node->id or $user->uid
 *    'entity_type' => string of the entity type. ex. 'node' or 'user' NOT 'node-content-custom'
 *
 * @return
 *   Array with status and reason.
 *     'status' => FALSE when no action is take, TRUE when points are credited or debited
 *     'reason' => (string) error message to indicate reason for failure
 */
function userpoints_userpointsapi($params) {
  global $user;

  // Test for the existence of parameters and set defaults if necessary.
  if (!isset($params['txn_id'])) {
    // If a txn_id is passed in we'll do an UPDATE thus the std checks don't apply.
    if (is_int($params)) {
      $params = array('points' => $params);
    }
    if (!is_array($params)) {
      // Has to be an array to continue.
      return array(
          'status' => FALSE,
          'reason' => 'Parameters did not properly form as an array,
                     this is an internal module error.
                    ',
      );
    }
    if (!isset($params['uid'])) {
      $params['uid'] = $user->uid;
    }

    // Check if parameters are set.
    $params_null_check = array('operation', 'description', 'reference', 'display', 'entity_id', 'entity_type');
    foreach ($params_null_check as $param_null_check) {
      if (!isset($params[$param_null_check])) {
        $params[$param_null_check] = NULL;
      }
    }

    if (!isset($params['moderate'])) {
      // If not passed then site default is used.
      $params['status'] = variable_get(USERPOINTS_POINTS_MODERATION, USERPOINTS_TXN_STATUS_APPROVED);
    }
    else {
      $params['status'] = $params['moderate'] ? USERPOINTS_TXN_STATUS_PENDING : USERPOINTS_TXN_STATUS_APPROVED;
    }
    if (!isset($params['tid']) || !is_numeric($params['tid'])) {
      // If not passed then site default is used.
      $params['tid'] = userpoints_get_default_tid();
    }

    // Anonymous users do not get points, and there have to be points to process.
    if (($params['uid'] == 0 || $params['points'] == 0)) {
      return array(
          'status' => FALSE,
          'reason' => 'uid or points = 0. Anonymous users do not get points
                     and there must be points to process.',
      );
    }
  }
  else {
    // We have a txn_id so we can look up some user information.
    $params['uid'] = db_query('SELECT uid from {userpoints_txn} WHERE txn_id = :txn_id', array(':txn_id' => $params['txn_id']))->fetchField();
  } // If txn_id.
  // Load the user object that will be awarded the points.
  $account = user_load($params['uid']);
  if (!$account) {
    return array(
        'status' => FALSE,
        'reason' => 'invalid uid or user account could not be loaded',
    );
  }

  // Call the _userpoints hook, and stop if one of them returns FALSE.
  $rc = userpoints_invoke_all('points before', $params);

  foreach ($rc as $key => $value) {
    if ($value == FALSE) {
      // Do not process the points.
      return array(
          'status' => FALSE,
          'reason' => t('@key returned FALSE from the hook_userpoints points before call', array('@key' => $key)),
      );
    }
  }

  $ret = _userpoints_transaction($params);
  if ($ret == FALSE) {
    return array(
        'status' => FALSE,
        'reason' => 'transaction failed in _userpoints_transaction, this is an internal module error',
    );
  }

  // Allow modules to define custom messages.
  if (!empty($params['message'])) {
    $message = $params['message'];
  }
  // Display message if either display property is not set and messages should
  // be displayed by default or display property is not FALSE.
  elseif (!empty($params['display']) || (!isset($params['display']) && variable_get(USERPOINTS_DISPLAY_MESSAGE, 1))) {
    // Prepare arguments. They are the same for all string combinations.
    $categories = userpoints_get_categories();
    $arguments = array_merge(userpoints_translation(), array(
      '!username' => theme('username', array('account' => $account)),
      '%total' => userpoints_get_current_points($params['uid'], $params['tid']),
      '%category' => isset($categories[$params['tid']]) ? $categories[$params['tid']] : $categories[0],
    ));

    $view_own_points = user_access('view own userpoints') || user_access('view userpoints') || user_access('administer userpoints');
    $view_all_points = user_access('view userpoints') || user_access('administer userpoints');

    if (isset($params['points']) && $params['points'] < 0) {
      if ($params['status'] == USERPOINTS_TXN_STATUS_PENDING) {
        if ($account->uid == $user->uid && $view_own_points) {
          // Directly address the user if he is loosing points.
          $message = format_plural(abs($params['points']), 'You just had a !point deducted, pending administrator approval.', 'You just had @count !points deducted, pending administrator approval.', $arguments);
        }
        elseif ($view_all_points) {
          // Only display message about other users if user has permission to view userpoints.
          $message = format_plural(abs($params['points']), '!username just had a !point deducted, pending administrator approval.', '!username just had @count !points deducted, pending administrator approval.', $arguments);
        }
      }
      else {
        if ($account->uid == $user->uid && $view_own_points) {
          $message = format_plural(abs($params['points']), 'You just had a !point deducted and have now %total !points in the %category category.', 'You just had @count !points deducted and now have %total !points in the %category category.', $arguments);
        }
        elseif ($view_all_points) {
          $message = format_plural(abs($params['points']), '!username just had a !point deducted and now has %total !points in the %category category.', '!username just had @count !points deducted and now has %total !points in the %category category.', $arguments);
        }
      }
    }
    elseif ($params['status'] == USERPOINTS_TXN_STATUS_DECLINED) {
      // Points have been declined.
      if ($account->uid == $user->uid && $view_own_points) {
        $message = format_plural(abs($params['points']), 'You were declined a !point in the %category category.', 'You were declined @count !points in the %category category.', $arguments);
      }
      elseif ($view_all_points) {
        $message = format_plural(abs($params['points']), '!username was declined a !point in the %category category.', '!username was declined @count !points in the %category category.', $arguments);
      }
    }
    elseif (!empty($params['points'])) {
      if ($params['status'] == USERPOINTS_TXN_STATUS_PENDING) {
        if ($account->uid == $user->uid && $view_own_points) {
          // Directly address the user if he is loosing points.
          $message = format_plural(abs($params['points']), 'You just earned a !point, pending administrator approval.', 'You just earned @count !points, pending administrator approval.', $arguments);
        }
        elseif ($view_all_points) {
          // Only display message about other users if user has permission to view userpoints.
          $message = format_plural(abs($params['points']), '!username just earned a !point, pending administrator approval.', '!username just earned @count !points, pending administrator approval.', $arguments);
        }
      }
      else {
        if ($account->uid == $user->uid && $view_own_points) {
          $message = format_plural(abs($params['points']), 'You just earned a !point and have now %total !points in the %category category.', 'You just earned @count !points and have now %total !points in the %category category.', $arguments);
        }
        elseif ($view_all_points) {
          $message = format_plural(abs($params['points']), '!username just earned a !point and now has %total !points in the %category category.', '!username just earned @count !points and now has %total !points in the %category category.', $arguments);
        }
      }
    }

    if (isset($message)) {
      drupal_set_message($message);
    }
  }
  // Call the _userpoints hook to allow modules to act after points are awarded.
  userpoints_invoke_all('points after', $params);
  return array(
      'status' => TRUE,
  );
}

/**
 * Adds the points to the txn table.
 */
function _userpoints_transaction(&$params) {
  // Check, again, for a properly formed array.
  if (!is_array($params)) {
    return FALSE;
  }
  if (!isset($params['txn_id'])) {
    // If a txn_id is preset we UPDATE the record instead of adding one
    // the standard checks don't apply.
    if (!is_numeric($params['points'])) {
      return FALSE;
    }
    if (!isset($params['uid'])) {
      global $user;
      $params['uid'] = $user->uid;
      // There must be a UID, anonymous does not receive points.
      if (!$params['uid'] > 0) {
        return FALSE;
      }
    }
    if (isset($params['expirydate']) && !is_numeric($params['expirydate'])) {
      return FALSE;
    }

    // Check if parameters are set.
    $params_null_check = array('operation', 'description', 'reference', 'expired', 'parent_txn_id', 'entity_id', 'entity_type');
    foreach ($params_null_check as $param_null_check) {
      if (!isset($params[$param_null_check])) {
        $params[$param_null_check] = NULL;
      }
    }

    if (!isset($params['tid']) || !is_numeric($params['tid'])) {
      $params['tid'] = userpoints_get_default_tid();
    }
    elseif ($params['tid'] == 0) {
      // Tid with 0 are uncategorized and are set to NULL
      // this is a backwards compatibilty issue.
      $params['tid'] = NULL;
    }
    if (!isset($params['expirydate'])) {
      $params['expirydate'] = userpoints_get_default_expiry_date();
    }
  } // If txn_id.
  // Control time_stamp functionality, by default with current timestamp.
  $time = REQUEST_TIME;
  // Overide system time if meeting criteria matches: Don't let future timestamps, Don't let bad formated timestamps.
  if (variable_get(USERPOINTS_TRANSACTION_TIMESTAMP, 1) || !isset($params['time_stamp']) || !is_numeric($params['time_stamp']) || $params['time_stamp'] > $time || $params['time_stamp'] < 0) {
    $params['time_stamp'] = $time;
  }
  // Always force changed timestamp to current REQUEST_TIME for transaction tracking.
  $params['changed'] = $time;

  if (!empty($params['txn_id']) && is_numeric($params['txn_id'])) {
    // A transaction ID was passed in so we'll update the transaction.
    $txn = db_query("SELECT txn_id, uid, approver_uid, points,
      time_stamp, status, operation, description, reference, expirydate, expired,
      parent_txn_id, tid, entity_id, entity_type
      FROM {userpoints_txn}
      WHERE txn_id = :txn_id",
                    array(':txn_id' => $params['txn_id']))->fetchAssoc();

    // Don't superseed existing keys, just complete missing keys.
    $params += $txn;
    // Update existing transaction record for key txn_id.
    $ret = drupal_write_record('userpoints_txn', $params, array('txn_id'));
    // Only update if the record has been successfully updated.
    if ($ret != FALSE) {
      _userpoints_update_cache($params);
    }
  }
  else {
    // Create new transaction record.
    $ret = drupal_write_record('userpoints_txn', $params);
    // Don't cache entry if it's pending.
    if ($params['status'] != TRUE && $ret != FALSE) {
      _userpoints_update_cache($params);
    }
  }
  return TRUE;
}

/**
 * Update the caching table
 */
function _userpoints_update_cache(&$params) {
  if ($params['status'] != USERPOINTS_TXN_STATUS_APPROVED || $params['expired'] == 1) {
    // Only update the cache for fully approved non-expired points.
    return FALSE;
  }
  if (!isset($params['tid'])) {
    $params['tid'] = 0;
  }

  // Calculate the current points based upon the tid.
  $current_points = (int) $params['points'] + userpoints_get_current_points($params['uid'], $params['tid']);
  // Grab the user's maximum points to preserve it.
  $max_points = (int) db_query('SELECT max_points FROM {userpoints} WHERE uid = :uid AND tid = :tid',
                  array(':uid' => $params['uid'], ':tid' => (int) $params['tid']))->fetchField();
  if ($params['points'] > 0) {
    // Points are greater than zero, update their max_points.
    $max_points = (int) $params['points'] + (int) $max_points;
  }

  // Insert or update the userpoints caching table with the user's current points.
  db_merge('userpoints')
          ->key(array(
              'uid' => $params['uid'],
              'tid' => (int) $params['tid'],
          ))
          ->fields(array(
              'points' => (int) $current_points,
              'max_points' => (int) $max_points,
              'last_update' => REQUEST_TIME,
          ))
          ->execute();
  unset($params);
}

/**
 * Determines the correct default expiration date.
 *
 * @return
 *   The default expiration date.
 */
function userpoints_get_default_expiry_date() {
  $expirydate = userpoints_date_to_timestamp(variable_get(USERPOINTS_EXPIREON_DATE, 0));
  if ($expirydate < REQUEST_TIME) {
    $expirydate = variable_get(USERPOINTS_EXPIREAFTER_DATE, 0);
    if ($expirydate) {
      $expirydate = REQUEST_TIME + $expirydate;
    }
  }
  return (int) $expirydate;
}

/*
 * Checks to ensure that a user exists corresponding to a category.
 *
 * @param $uid
 *   User ID to check for existence of points for the user.
 * @param $tid
 *   taxonomy id of the category to limit to, if omitted
 *   if the use has points in any category the return is TRUE.
 * @return
 *  TRUE if user found, FALSE otherwise.
 */

function _userpoints_user_exists($uid, $tid = NULL) {
  if (is_numeric($tid)) {
    return (int) db_query('SELECT COUNT(uid)
      FROM {userpoints}
      WHERE uid = :uid AND tid = :tid',
            array(':uid' => $uid, ':tid' => $tid))->fetchField();
  }
  else {
    return (int) db_query('SELECT COUNT(uid)
      FROM {userpoints}
      WHERE uid = :uid',
            array(':uid' => $uid))->fetchField();
  }
}

/**
 * Implements hook_user_delete().
 */
function userpoints_user_delete($account) {
  // The user is being deleted, delete all traces in userpoints and txn tables.
  db_delete('userpoints')
          ->condition('uid', $account->uid)
          ->execute();
  db_delete('userpoints_txn')
          ->condition('uid', $account->uid)
          ->execute();
}

/**
 * Implements hook_user_view().
 */
function userpoints_user_view($account, $view_mode) {
  global $user;
  if (user_access('view userpoints') || (user_access('view own userpoints') && $user->uid == $account->uid )) {
    $details = NULL;
    if (userpoints_access_my_points($account->uid)) {
      $details .= l(t('View'), 'myuserpoints/' . $account->uid, array('attributes' => array('title' => t('View detailed transactions'))));
    }
    if (user_access('administer userpoints')) {
      if (!is_null($details)) {
        $details .= ', ';
      }
      $details .= l(t('Adjust'), 'admin/config/people/userpoints/add/' . $account->uid, array('attributes' => array('title' => t('Add/substract !points from this user', userpoints_translation()))));
    }

    // Which points are we displaying.
    $points = userpoints_get_current_points($account->uid, variable_get(USERPOINTS_CATEGORY_PROFILE_DISPLAY_TID, 0));

    $account->content['userpoints'] = array(
        '#type' => 'user_profile_category',
        '#title' => t('User !points', userpoints_translation()),
    );
    $account->content['userpoints']['points'] = array(
        '#type' => 'user_profile_item',
        '#title' => t('!Points', userpoints_translation()),
        '#markup' => $details ? $points . ' - ' . $details : $points,
    );
  }
}

/**
 * Provides a dropdown to filter by category.
 */
function userpoints_filter_cat_select($form, &$form_state, $path, $tid) {
  $current_cat = url($path . $tid);
  $form = array();
  $formname = 'catselect';
  $sql = "SELECT DISTINCT p.tid, t.name
          FROM {userpoints_txn} p
          LEFT JOIN {taxonomy_term_data} t on p.tid = t.tid";
  $cats = userpoints_get_categories();
  $options = array();
  $options[url($path)] = t('Display all');
  foreach ($cats as $key => $value) {
    $options[url($path . $key)] = $value;
  }
  $form['catselect'] = array(
      '#type' => 'select',
      '#name' => $formname,
      '#id' => $formname,
      '#title' => t('Filter by category'),
      '#default_value' => $current_cat,
      '#options' => $options,
      '#multiple' => FALSE,
      '#required' => FALSE,
      '#attributes' => array('onChange' => "top.location.href=document.getElementById('$formname').options[document.getElementById('$formname').selectedIndex].value"),
  );

  return $form;
}

/**
 * Implements hook_block_info().
 */
function userpoints_block_info() {
  $blocks[-1]['info'] = t('User\'s !points', userpoints_translation());
  // Grab a list of the available terms.
  $terms = userpoints_get_categories();
  foreach ($terms as $key => $value) {
    $blocks[$key]['info'] = t("Highest $value !points", userpoints_translation());
    ;
  }

  return $blocks;
}

/**
 * Implements hook_block_view().
 */
function userpoints_block_view($delta) {
  global $user;
  if ($delta == -1 && (user_access('view userpoints') || user_access('view own userpoints'))) {
    $title = t('!user\'s !points', array_merge(array('!user' => theme('username', array('account' => $user))), userpoints_translation()));
    if ($user->uid) {
      $points = userpoints_get_current_points($user->uid, variable_get(USERPOINTS_CATEGORY_PROFILE_DISPLAY_TID, 0));
      $show_points = format_plural($points, '!point', '!points', userpoints_translation());
      $content = t('You have %p %c', array('%p' => $points, '%c' => $show_points));
    }
    else {
      $content = t('!Points are visible to logged in users only', userpoints_translation());
    }
  }
  elseif (user_access('view userpoints')) {
    // $delta is our tid for pulling the points.
    // If 0 we pull 0 or NULL.
    $title = t('Highest Users');

    $query = db_select('userpoints', 'p')
                    ->fields('p', array('uid', 'points'))
                    ->orderBy('p.points', 'DESC')
                    ->range(0, variable_get('userpoints_block_up_records_' . $delta, 5));
    if ($delta == 0) {
      $query->condition(db_or()->condition('p.tid', 0)->isNull('p.tid'));
    }
    else {
      $query->condition('p.tid', $delta);
    }

    // Exclude blocked users.
    $query->join('users', 'u', 'u.uid = p.uid AND u.status = 1');

    $rows = array();
    foreach ($query->execute() as $data) {
      $rows[] =
              array(
                  array('data' => theme('username', array('account' => user_load($data->uid)))),
                  array('data' => $data->points, 'align' => 'right'));
    }
    $header = array(t('User'), t('!Points', userpoints_translation()));
    $content = theme('table', array('header' => $header, 'rows' => $rows));
    $content .= '<div class="more-link">' . l(t('more'), 'userpoints/' . $delta, array('attributes' => array('title' => t('All users by !points', userpoints_translation())))) . '</div>';
  }

  if (!empty($title) && !empty($content)) {
    $block['subject'] = $title;
    $block['content'] = $content;
    return $block;
  }
}

/**
 * Implements hook_block_configure().
 */
function userpoints_block_configure($delta) {
  if ($delta > 1) {
    $form['up_records'] = array(
        '#type' => 'select',
        '#title' => t('Number of users to display'),
        '#default_value' => variable_get('userpoints_block_up_records_' . $delta, 10),
        '#options' => array(
            1 => 1, 5 => 5, 10 => 10, 15 => 15, 20 => 20,
            30 => 30, 40 => 40, 50 => 50, 60 => 60,
            70 => 70, 80 => 80, 90 => 90, 100 => 100, 200 => 200,
        ),
        '#description' => t('Limit the number of users displayed to this value'),
    );
    return $form;
  }
}

/**
 * Implements hook_block_save().
 */
function userpoints_block_save($delta, $edit) {
  variable_set('userpoints_block_up_records_' . $delta, isset($edit['up_records']) ? $edit['up_records'] : 10);
}

/**
 * returns an array of possible expiry times
 * to the administrative settings page
 */
function expiry_dates() {
  return array(
      NULL => 'Never',
      3600 => 'One hour',
      86400 => 'One Day',
      604800 => 'One Week',
      1209600 => 'Two Weeks',
      2419200 => 'Four Weeks',
      31536000 => '365 Days',
  );
}

/**
 * Modifies FAPI date setting to timestamp.
 *
 * @return
 *   UNIX timestamp.
 */
function userpoints_date_to_timestamp($date) {
  //This takes the FAPI date form array and returns a timestamp
  if ($date) {
    return mktime(0, 0, 0, $date['month'], $date['day'], $date['year']);
  }
}

/**
 * Finds and expires expired points.
 *
 * Finds all transactions with a expirydate < REQUEST_TIME and posts
 * opposite transactions (sum of 0).
 */
function userpoints_expire_transactions() {
  $sql = "SELECT txn_id, uid, points, time_stamp, operation, description, tid
          FROM {userpoints_txn}
          WHERE status = 0 AND expired = 0
          AND (expirydate < :expiry_date AND expirydate != 0)";
  $result = db_query($sql, array(':expiry_date' => REQUEST_TIME));
  foreach ($result as $line) {
    $time_stamp_formatted = format_date($line->time_stamp, 'custom', 'Y-m-d H:i');
    $arguments = array_merge(userpoints_translation(), array(
      '!operation' => $line->operation,
      '!description' => $line->description,
      '!txn_id' => $line->txn_id,
      '!date' => $time_stamp_formatted,
    ));
    $description = t(variable_get(USERPOINTS_EXPIRY_DESCRIPTION, NULL), $arguments);

    $params = array(
        'points' => -$line->points,
        'uid' => $line->uid,
        'operation' => 'expiry',
        'description' => $description,
        'parent_txn_id' => $line->txn_id,
        'moderate' => FALSE,
        'tid' => $line->tid,
        'time_stamp' => $line->time_stamp,
    );
    userpoints_userpointsapi($params);
    // Ok we've expired the entry lets update the original entry to set the
    // expired flag.
    $params = array(
        'txn_id' => $line->txn_id,
        'expired' => 1,
    );
    userpoints_userpointsapi($params);
  }
}

/**
 * Implements hook_cron().
 */
function userpoints_cron() {
  userpoints_expire_transactions();
}


/**
 *  Returns the Vocabulary ID (vid) used by userpoints for categorization.
 *
 *  If no vocab exists it will create one.
 */
function userpoints_get_vid() {
  if (!module_exists('taxonomy')) {
    return FALSE;
  }
  // Code lovingly inspired by the image.module w/ code by drewish.
  $vid = variable_get(USERPOINTS_CATEGORY_DEFAULT_VID, '');
  if (empty($vid) || !taxonomy_vocabulary_load($vid)) {
    $sql = "SELECT vid FROM {taxonomy_vocabulary} WHERE module='userpoints'";
    $vid = db_query($sql)->fetchField();
    if (!$vid) {
      drupal_set_message(t("Created Userpoints vocabulary"));
      // No vocabulary exists, we'll create one.
      $vocab = (object) array(
          'name' => USERPOINTS_CATEGORY_NAME,
          'description' => t('Automatically created by the userpoints module'),
          'machine_name' => 'userpoints',
          'multiple' => '0',
          'required' => '0',
          'hierarchy' => '1',
          'relations' => '0',
          'module' => 'userpoints',
      );
      taxonomy_vocabulary_save($vocab);
      $vid = $vocab->vid;
    }
    variable_set(USERPOINTS_CATEGORY_DEFAULT_VID, $vid);
  }
  if (!is_numeric($vid)) {
    watchdog('userpoints', 'userpoints module was unable to select or create a vocabulary. !Points will be uncategorized', array(), WATCHDOG_ERROR);
  }
  return $vid;
}

/**
 * Returns an array of possible categories, suitable for inclusion in FAPI.
 */
function userpoints_get_categories() {
  // Create the "Uncategorized" category.
  $options = array();
  $options[0] = t('!Uncategorized', userpoints_translation());
  if (module_exists('taxonomy')) {
    $vid = userpoints_get_vid();
    if ($vid) {
      $tree = taxonomy_get_tree($vid);
      foreach ($tree as $term) {
        $options[$term->tid] = $term->name;
      }
    }
  }
  return $options;
}

/**
 * Wrapper function to return the default tid via API call
 */
function userpoints_get_default_tid() {
  return (int) variable_get(USERPOINTS_CATEGORY_DEFAULT_TID, 0);
}


/**
 * Implements hook_views_api().
 */
function userpoints_views_api() {
  return array(
      'api' => 2.0,
  );
}

/**
 * Invokes hook_userpoints() with params passed by references.
 *
 * @param $op
 *   The operation being performed.
 * @param &$params
 *   Parameters to be passed to the hook.
 * 
 * @return
 *   An array of return values of the hook implementations. If modules return
 *   arrays from their implementations, those are merged into one array.
 */
function userpoints_invoke_all($op, &$params = array()) {
  $return = array();
  foreach (module_implements('userpoints') as $module) {
    $function = $module .'_userpoints';
    $result = $function($op, $params);
    if (isset($result) && is_array($result)) {
      $return = array_merge_recursive($return, $result);
    }
    else if (isset($result)) {
      $return[] = $result;
    }
  }
  return $return;
}
